# Roadmap v1.0.5 - Correcci√≥n de Debilidades Identificadas

**‚ö†Ô∏è OBSOLETO: Este documento ha sido superado por la versi√≥n v1.0.6**

**Versi√≥n**: 1.0.5 (Planificado - IMPLEMENTADO en v1.0.6)  
**Fecha**: Post 2026-01-10  
**Base**: v1.0.4 (Smart Pointers Completado)  
**Estado**: COMPLETADO en v1.0.6 (ver [CHANGELOG.md](CHANGELOG.md))

---

## ‚úÖ Estado de Implementaci√≥n (v1.0.6)

Todas las debilidades identificadas han sido corregidas en v1.0.6:

1. **‚úÖ Control de errores en threading**: Signal handler implementado para SIGINT/SIGTERM
2. **‚úÖ Logging/diagn√≥sticos**: RuntimeLogger completo con buffer circular (solo hilos control)
3. **‚úÖ Configuraci√≥n dispersa**: system_config.h centraliza todas las constantes (SSOT)
4. **‚úÖ Contenci√≥n de mutex**: Evidencia < 2 Œºs wait, 0 WARNING/CRITICAL en 10000+ iteraciones
5. **‚úÖ Error logging**: stderr redirigido a logs/error_log_YYYYMMDD_HHMMSS.txt

**Ver detalles completos en**:
- [CHANGELOG.md](CHANGELOG.md) - Secci√≥n v1.0.6
- [ASSESSMENT.md](ASSESSMENT.md) - Debilidades corregidas
- [ARCHITECTURE.md](ARCHITECTURE.md) - Implementaci√≥n t√©cnica

---

## üéØ Objetivos v1.0.5 (SUPERADOS)

~~Corregir las debilidades identificadas en [doc/ASSESSMENT.md](ASSESSMENT.md) que a√∫n persisten tras completar v1.0.4:~~

1. ~~**Falta de control de errores en threading**~~ ‚úÖ Signal handler implementado
2. ~~**Ausencia de logging/diagn√≥sticos**~~ ‚úÖ RuntimeLogger completo (selectivo)
3. ~~**Configuraci√≥n dispersa de frecuencias**~~ ‚úÖ system_config.h (SSOT)
4. ~~**Mutex √∫nico compartido (posible contenci√≥n)**~~ ‚úÖ Sin contenci√≥n observada (< 2 Œºs)
5. ~~**Scheduling no configurado (jitter alto)**~~ ‚úÖ Temporizador con TIMER_ABSTIME

---

## üìã Debilidades a Corregir (COMPLETADO)

### 1. Falta de Control de Errores en `pthread_create`/`pthread_join`

**Problema Actual**:
```cpp
// En Hilo::Hilo (ejemplo)
pthread_create(&thread_, nullptr, &Hilo::run_static, this);
// ‚ö†Ô∏è No se verifica retorno (int retval)
```

**Soluci√≥n Propuesta (v1.0.5)**:
```cpp
// Verificar retorno de pthread_create
int ret = pthread_create(&thread_, nullptr, &Hilo::run_static, this);
if (ret != 0) {
    std::cerr << "Error: pthread_create failed with code " << ret << std::endl;
    throw std::runtime_error("Thread creation failed");
}

// En destructor, verificar pthread_join
int join_ret = pthread_join(thread_, nullptr);
if (join_ret != 0) {
    std::cerr << "Warning: pthread_join failed with code " << join_ret << std::endl;
}
```

**Archivos a Actualizar**:
- `include/Hilo*.h` (todas las clases)
- `src/Hilo*.cpp` (todas las implementaciones)

**Checklist**:
- [ ] Hilo.h/cpp
- [ ] Hilo2in.h/cpp
- [ ] HiloPID.h/cpp
- [ ] HiloSignal.h/cpp
- [ ] HiloSwitch.h/cpp
- [ ] HiloIntArranque.h/cpp
- [ ] HiloTransmisor.h/cpp
- [ ] HiloReceptor.h/cpp

---

### 2. Logging B√°sico para Diagn√≥sticos

**Problema Actual**:
- No hay trazas de ejecuci√≥n
- Dif√≠cil diagnosticar qu√© hilo fall√≥
- Sin timestamp para an√°lisis de jitter

**Soluci√≥n Propuesta (v1.0.5)**:
Crear clase `Logger` simple en `include/Logger.h`:

```cpp
namespace DiscreteSystems {

class Logger {
public:
    enum Level { DEBUG, INFO, WARNING, ERROR };
    
    static void log(Level level, const std::string& thread_name, const std::string& message);
    static void setLevel(Level min_level);
    
private:
    static Level min_level_;
    static std::mutex log_mutex_;
    
    static std::string levelToString(Level level);
    static std::string getCurrentTimestamp();
};

}

// Uso en hilos:
Logger::log(Logger::INFO, "Hilo", "Sistema discreto iniciado");
```

**Archivos**:
- [ ] Crear `include/Logger.h`
- [ ] Crear `src/Logger.cpp`
- [ ] Agregar a `CMakeLists.txt`
- [ ] Actualizar `src/Hilo*.cpp` para usar Logger

---

### 3. Configuraci√≥n Centralizada de Frecuencias

**Problema Actual**:
```cpp
// En testHilo.cpp: frecuencias dispersas
const double Ts_controller = 0.01;
const double Ts_component  = Ts_controller / 10.0;
const double freq_controller = 1.0 / Ts_controller;
const double freq_component  = 1.0 / Ts_component;
// ... m√°s configuraci√≥n diseminada
```

**Soluci√≥n Propuesta (v1.0.5)**:
Crear `include/Config.h` inmutable:

```cpp
namespace DiscreteSystems {

struct Config {
    // Per√≠odos de muestreo (segundos)
    static constexpr double Ts_controller = 0.01;      // 100 Hz
    static constexpr double Ts_component  = 0.001;     // 1 kHz
    
    // Frecuencias derivadas (Hz)
    static constexpr double freq_controller() { return 1.0 / Ts_controller; }
    static constexpr double freq_component()  { return 1.0 / Ts_component; }
    
    // Tama√±os de buffer
    static constexpr size_t buffer_size = 10;
    
    // Par√°metros de planta
    static constexpr double plant_tau = 1.0;  // constante de tiempo
    
    // IPC
    static constexpr const char* mqueue_data_name = "/DiscreteSystems_data";
    static constexpr const char* mqueue_params_name = "/DiscreteSystems_params";
    static constexpr size_t mqueue_max_msg_size = 256;
    
    // Logging
    static constexpr bool logging_enabled = true;
    static constexpr Logger::Level min_log_level = Logger::INFO;
};

}
```

**Beneficios**:
- Una √∫nica fuente de verdad
- F√°cil de ajustar par√°metros
- Compilaci√≥n constexpr (sin overhead runtime)

**Archivos**:
- [ ] Crear `include/Config.h`
- [ ] Actualizar `test/testHilo.cpp` para usar `Config::`
- [ ] Actualizar `Interfaz_Control/src/control_simulator.cpp` (si aplica)

---

### 4. Separaci√≥n de Mutex por Variable

**Problema Actual**:
```cpp
// Un mutex √∫nico protege todo
struct VariablesCompartidas {
    pthread_mutex_t mtx;  // Protege: ref, e, u, ua, yk, ykd, running
    double ref, e, u, ua, yk, ykd;
    bool running;
};
// ‚ö†Ô∏è Posible contenci√≥n si muchos hilos acceden simult√°neamente
```

**Soluci√≥n Propuesta (v1.0.5)**:
```cpp
// Reemplazar pthread_mutex_t con std::mutex
struct VariablesCompartidas {
    std::mutex mtx_ref;      // Protege: ref
    std::mutex mtx_error;    // Protege: e
    std::mutex mtx_control;  // Protege: u, ua
    std::mutex mtx_output;   // Protege: yk, ykd
    std::mutex mtx_running;  // Protege: running
    
    double ref, e, u, ua, yk, ykd;
    bool running;
};

// Uso:
{
    std::lock_guard<std::mutex> lock(vars.mtx_ref);
    auto ref_val = vars.ref;
}
```

**Alternativa: Usar `std::atomic<>`**:
```cpp
struct VariablesCompartidas {
    std::atomic<double> ref{0.0};
    std::atomic<double> e{0.0};
    std::atomic<double> u{0.0};
    // ...
    std::atomic<bool> running{false};
};

// Uso:
vars.ref.store(1.0, std::memory_order_release);
double val = vars.ref.load(std::memory_order_acquire);
```

**Archivos**:
- [ ] Crear `include/VariablesCompartidas.h` (nuevo dise√±o con separaci√≥n de mutex)
- [ ] Actualizar `src/VariablesCompartidas.cpp`
- [ ] Actualizar todos los `Hilo*.cpp` para usar nuevo esquema

---

### 5. Configuraci√≥n de Scheduler FIFO/RR

**Problema Actual**:
- Scheduling por defecto (SCHED_OTHER) tiene jitter alto
- Depende de carga del sistema
- No determin√≠stico en tiempo real

**Soluci√≥n Propuesta (v1.0.5)**:
Agregar funci√≥n en `include/ThreadUtils.h`:

```cpp
namespace DiscreteSystems {

class ThreadUtils {
public:
    /**
     * @brief Establecer scheduling FIFO/RR para el hilo actual
     * @param priority Prioridad (1-99 para FIFO/RR)
     * @param use_fifo true para FIFO, false para RR
     * @return 0 si √©xito, -1 si falla (requiere privilegios)
     */
    static int setRealtimeScheduling(int priority, bool use_fifo = true);
    
    /**
     * @brief Obtener nombre del hilo actual
     */
    static std::string getThreadName();
};

}
```

**Implementaci√≥n**:
```cpp
int ThreadUtils::setRealtimeScheduling(int priority, bool use_fifo) {
    struct sched_param param;
    param.sched_priority = priority;
    
    int policy = use_fifo ? SCHED_FIFO : SCHED_RR;
    int ret = pthread_setschedparam(pthread_self(), policy, &param);
    
    if (ret != 0) {
        Logger::log(Logger::WARNING, "ThreadUtils", 
                   "Failed to set realtime scheduling (requires root)");
    }
    return ret;
}
```

**Uso Sugerido en Hilos**:
```cpp
void Hilo::run() {
    // Opcional: establecer FIFO con prioridad 50
    // ThreadUtils::setRealtimeScheduling(50, true);
    
    // Resto del loop...
    while (true) {
        // ...
    }
}
```

**Archivos**:
- [ ] Crear `include/ThreadUtils.h`
- [ ] Crear `src/ThreadUtils.cpp`
- [ ] Documento: `doc/REALTIME-SCHEDULER.md` (gu√≠a)

---

## üìä Tabla de Implementaci√≥n v1.0.5

| Mejora | Archivos | Complejidad | Impacto | Estimado |
|--------|----------|-------------|--------|----------|
| 1. Error Handling | 8 Hilo*.h/cpp | ‚≠ê Baja | Alto | 2h |
| 2. Logging | Logger.h/cpp + Hilo*.cpp | ‚≠ê‚≠ê Media | Alto | 3h |
| 3. Config Centralizada | Config.h + test/testHilo.cpp | ‚≠ê Baja | Alto | 1h |
| 4. Mutex Separados | VariablesCompartidas.h/cpp | ‚≠ê‚≠ê‚≠ê Alta | Medio | 4h |
| 5. Real-time Scheduler | ThreadUtils.h/cpp + docs | ‚≠ê‚≠ê Media | Medio | 2h |

**Total Estimado**: ~12 horas

---

## ‚úÖ Checklist de Implementaci√≥n

- [ ] **Fase 1: Error Handling** (2h)
  - [ ] Actualizar constructores Hilo*
  - [ ] Actualizar destructores Hilo*
  - [ ] Tests de error handling
  - [ ] Documentar en Doxygen

- [ ] **Fase 2: Logging** (3h)
  - [ ] Crear Logger.h/cpp
  - [ ] Integrar en Hilo*.cpp
  - [ ] Test de logs
  - [ ] Doxygen

- [ ] **Fase 3: Config Centralizada** (1h)
  - [ ] Crear Config.h
  - [ ] Refactorizar testHilo.cpp
  - [ ] Refactorizar control_simulator.cpp (si aplica)

- [ ] **Fase 4: Mutex Separados** (4h)
  - [ ] Dise√±o de nueva VariablesCompartidas
  - [ ] Implementaci√≥n
  - [ ] Actualizar todos los Hilo*.cpp
  - [ ] Tests exhaustivos
  - [ ] CHANGELOG

- [ ] **Fase 5: Real-time Scheduler** (2h)
  - [ ] Crear ThreadUtils.h/cpp
  - [ ] Documentaci√≥n
  - [ ] Ejemplos en Doxygen

---

## üîÑ Integraci√≥n Continua (CI)

Agregar **GitHub Actions** en v1.0.5:

```yaml
# .github/workflows/build.yml
name: Build & Test
on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build
        run: cd build && cmake .. && make
      - name: Tests
        run: cd bin && ./testHilo
      - name: Linting
        run: clang-tidy src/*.cpp -- -I./include
      - name: Sanitizers
        run: ASAN_OPTIONS=detect_leaks=1 ./bin/testHilo
```

---

## üìù Documentaci√≥n Adicional

Se deben crear estos documentos en v1.0.5:

1. **doc/LOGGING.md**: Gu√≠a de uso del sistema de logging
2. **doc/CONFIG.md**: Explicaci√≥n de par√°metros centralizados
3. **doc/REALTIME-SCHEDULER.md**: Gu√≠a de configuraci√≥n FIFO/RR
4. **doc/ERROR-HANDLING.md**: Estrategia de manejo de errores en threading

---

## üöÄ Lanzamiento v1.0.5

- [ ] Todas las mejoras implementadas
- [ ] Tests unitarios + integraci√≥n
- [ ] Doxygen regenerado
- [ ] CHANGELOG.md actualizado
- [ ] Git tag: `v1.0.5`
- [ ] GitHub release con notas

---

## üìñ Referencias

- [doc/ASSESSMENT.md](ASSESSMENT.md) - Evaluaci√≥n completa
- [doc/CHANGELOG.md](CHANGELOG.md) - Historial de versiones
- [include/Hilo.h](../include/Hilo.h) - Patr√≥n actual de threading
- [POSIX Threads Documentation](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html)
- [C++ Concurrency](https://cplusplus.com/reference/thread/)

